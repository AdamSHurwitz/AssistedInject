package com.squareup.inject.inflation.processor

import com.google.auto.service.AutoService
import com.squareup.inject.assisted.processor.AssistedInjection
import com.squareup.inject.assisted.processor.Key
import com.squareup.inject.assisted.processor.asDependencyRequest
import com.squareup.inject.assisted.processor.assistedInjectFactoryName
import com.squareup.inject.assisted.processor.internal.cast
import com.squareup.inject.assisted.processor.internal.findElementsAnnotatedWith
import com.squareup.inject.assisted.processor.internal.hasAnnotation
import com.squareup.inject.inflation.InflationInject
import com.squareup.inject.inflation.InflationModule
import com.squareup.inject.inflation.ViewFactory
import com.squareup.javapoet.AnnotationSpec
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.TypeSpec
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.Filer
import javax.annotation.processing.Messager
import javax.annotation.processing.ProcessingEnvironment
import javax.annotation.processing.Processor
import javax.annotation.processing.RoundEnvironment
import javax.lang.model.SourceVersion
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.Modifier.ABSTRACT
import javax.lang.model.element.Modifier.PRIVATE
import javax.lang.model.element.Modifier.PUBLIC
import javax.lang.model.element.TypeElement
import javax.tools.Diagnostic.Kind.ERROR

@AutoService(Processor::class)
class InflationInjectProcessor : AbstractProcessor() {
  override fun getSupportedSourceVersion() = SourceVersion.latest()
  override fun getSupportedAnnotationTypes() = setOf(
      InflationInject::class.java.canonicalName,
      InflationModule::class.java.canonicalName
  )

  override fun init(env: ProcessingEnvironment) {
    super.init(env)
    messager = env.messager
    filer = env.filer
  }

  private lateinit var messager: Messager
  private lateinit var filer: Filer

  override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
    val constructors = roundEnv.findElementsAnnotatedWith<InflationInject>()
        .cast<ExecutableElement>()

    constructors.forEach { constructor ->
      val type = constructor.enclosingElement as TypeElement
      val targetType = ClassName.get(type)
      val dependencyRequests = constructor.parameters.map { it.asDependencyRequest() }
      val assistedInjection = AssistedInjection(targetType, dependencyRequests, FACTORY, "create",
          VIEW, assistedKeys = FACTORY_KEYS)

      val generatedTypeSpec = assistedInjection.brewJava()
          .toBuilder()
          .addOriginatingElement(type)
          .build()
      JavaFile.builder(assistedInjection.generatedType.packageName(), generatedTypeSpec)
          .addFileComment("Generated by @InflationInject. Do not modify!")
          .build()
          .writeTo(filer)
    }

    val inflationModules = roundEnv.findElementsAnnotatedWith<InflationModule>()
        .cast<TypeElement>()
    if (inflationModules.size > 1) {
      inflationModules.forEach {
        messager.printMessage(ERROR, "Multiple @InflationModule-annotated modules found.", it)
      }
    }

    inflationModules.filterNot { it.hasAnnotation("dagger.Module") }
        .forEach {
          messager.printMessage(ERROR, "@InflationModule must also be annotated with @Module.", it)
        }

    // TODO validate includes={} includes the generated type.

    inflationModules.firstOrNull()?.let {
      val moduleName = ClassName.get(it)
      val generatedModuleName = moduleName.inflationModuleName()

      val moduleSpecBuilder = TypeSpec.classBuilder(generatedModuleName)
          .addAnnotation(MODULE)
          .addModifiers(PUBLIC, ABSTRACT)
          .addMethod(MethodSpec.constructorBuilder()
              .addModifiers(PRIVATE)
              .build())

      constructors.forEach { constructor ->
        val type = constructor.enclosingElement as TypeElement
        val typeName = ClassName.get(type)
        val factoryTypeName = typeName.assistedInjectFactoryName()

        moduleSpecBuilder.addMethod(
            MethodSpec.methodBuilder(typeName.bindMethodName())
                .addAnnotation(BINDS)
                .addAnnotation(INTO_MAP)
                .addAnnotation(AnnotationSpec.builder(STRING_KEY)
                    .addMember("value", "\$S", type.qualifiedName.toString())
                    .build())
                .addModifiers(ABSTRACT)
                .returns(ViewFactory::class.java)
                .addParameter(factoryTypeName, "factory")
                .build())
      }

      JavaFile.builder(generatedModuleName.packageName(), moduleSpecBuilder.build())
          .addFileComment("Generated by @InflationModule. Do not modify!")
          .build()
          .writeTo(filer)
    }

    return false
  }
}

private val MODULE = ClassName.get("dagger", "Module")
private val BINDS = ClassName.get("dagger", "Binds")
private val INTO_MAP = ClassName.get("dagger.multibindings", "IntoMap")
private val STRING_KEY = ClassName.get("dagger.multibindings", "StringKey")
private val VIEW = ClassName.get("android.view", "View")
private val FACTORY = ClassName.get(ViewFactory::class.java)
private val FACTORY_KEYS = listOf(
    Key(ClassName.get("android.content", "Context")),
    Key(ClassName.get("android.util", "AttributeSet")))
private fun ClassName.bindMethodName() = "bind_" + reflectionName().replace('.', '_')
private fun ClassName.inflationModuleName() = peerClass("InflationInject_" + simpleName())
