package com.squareup.inject.inflation.processor

import com.google.auto.service.AutoService
import com.squareup.inject.assisted.processor.AssistedInjectRequest
import com.squareup.inject.assisted.processor.asParameterKey
import com.squareup.inject.assisted.processor.internal.findElementsAnnotatedWith
import com.squareup.inject.inflation.InflationInject
import com.squareup.inject.inflation.InflationModule
import com.squareup.inject.inflation.ViewFactory
import com.squareup.javapoet.AnnotationSpec
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.ParameterizedTypeName
import com.squareup.javapoet.TypeName
import com.squareup.javapoet.TypeSpec
import com.squareup.javapoet.WildcardTypeName
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.Filer
import javax.annotation.processing.Messager
import javax.annotation.processing.ProcessingEnvironment
import javax.annotation.processing.Processor
import javax.annotation.processing.RoundEnvironment
import javax.lang.model.SourceVersion
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.Modifier.ABSTRACT
import javax.lang.model.element.Modifier.PRIVATE
import javax.lang.model.element.Modifier.PUBLIC
import javax.lang.model.element.TypeElement
import javax.lang.model.element.VariableElement

@AutoService(Processor::class)
class InflationInjectProcessor : AbstractProcessor() {
  override fun getSupportedSourceVersion() = SourceVersion.latest()
  override fun getSupportedAnnotationTypes() = setOf(
      InflationInject::class.java.canonicalName,
      InflationModule::class.java.canonicalName
  )

  override fun init(env: ProcessingEnvironment) {
    super.init(env)
    messager = env.messager
    filer = env.filer

    factory = env.elementUtils.getTypeElement(ViewFactory::class.java.canonicalName)
    factoryMethod = factory.enclosedElements.filterIsInstance<ExecutableElement>().single()
  }

  private lateinit var messager: Messager
  private lateinit var filer: Filer

  private lateinit var factory: TypeElement
  private lateinit var factoryMethod: ExecutableElement

  override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
    val constructors = roundEnv.findElementsAnnotatedWith<InflationInject>()
        .map { it as ExecutableElement }
    if (constructors.isNotEmpty()) {
      val moduleType = roundEnv.findElementsAnnotatedWith<InflationModule>()
          .single() as TypeElement

      val moduleName = ClassName.get(moduleType)
      val generatedModuleName = moduleName.peerClass("InflationInject_" + moduleName.simpleName())

      val moduleSpecBuilder = TypeSpec.classBuilder(generatedModuleName)
          .addAnnotation(MODULE)
          .addModifiers(PUBLIC, ABSTRACT)
          .addMethod(MethodSpec.constructorBuilder()
              .addModifiers(PRIVATE)
              .build())

      constructors.forEach { constructor ->
        val type = constructor.enclosingElement as TypeElement
        val parameterKeys = constructor.parameters.map(VariableElement::asParameterKey)
        val request = AssistedInjectRequest(type, factory, factoryMethod, parameterKeys)

        moduleSpecBuilder.addMethod(
            MethodSpec.methodBuilder(ClassName.get(type).bindMethodName())
                .addAnnotation(BINDS)
                .addAnnotation(INTO_MAP)
                .addAnnotation(AnnotationSpec.builder(STRING_KEY)
                    .addMember("value", "\$S", type.qualifiedName.toString())
                    .build())
                .returns(VIEW_FACTORY_WILDCARD)
                .addModifiers(ABSTRACT)
                .addParameter(request.generatedClassName, "factory")
                .build())

        JavaFile.builder(request.generatedClassName.packageName(), request.brewJava())
            .addFileComment("Generated by @InflationInject. Do not modify!")
            .build()
            .writeTo(filer)
      }

      JavaFile.builder(generatedModuleName.packageName(), moduleSpecBuilder.build())
          .addFileComment("Generated by @InflationModule. Do not modify!")
          .build()
          .writeTo(filer)
    }

    return false
  }
}

private val MODULE = ClassName.get("dagger", "Module")
private val BINDS = ClassName.get("dagger", "Binds")
private val INTO_MAP = ClassName.get("dagger.multibindings", "IntoMap")
private val STRING_KEY = ClassName.get("dagger.multibindings", "StringKey")
private val VIEW_FACTORY_WILDCARD = ParameterizedTypeName.get(
    ClassName.get(ViewFactory::class.java),
    WildcardTypeName.subtypeOf(TypeName.OBJECT))
private fun ClassName.bindMethodName() = "bind_" + reflectionName().replace('.', '_')
